<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Capturador 99 OCR</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#6366f1">
    
    <!-- PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Capturador 99">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Tesseract.js for OCR -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.3/dist/tesseract.min.js"></script>
    
    <style>
        .loading {
            animation: spin 2s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .card-corrida {
            transition: all 0.3s ease;
        }
        .card-corrida:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
        }
        .info-badge {
            display: inline-flex;
            align-items: center;
            padding: 2px 8px;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 500;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-900 min-h-screen">
    
    <!-- Header -->
    <div class="max-w-4xl mx-auto p-4">
        <div class="bg-white/95 backdrop-blur-sm rounded-2xl shadow-2xl p-6 mb-6">
            <div class="flex items-center gap-3 mb-6">
                <div class="bg-gradient-to-r from-purple-500 to-pink-500 p-3 rounded-full">
                    <div class="w-8 h-8 text-white text-2xl">üì∑</div>
                </div>
                <div>
                    <h1 class="text-2xl font-bold text-gray-800">Capturador OCR 99</h1>
                    <p class="text-gray-600">Screenshot ‚Üí OCR ‚Üí An√°lise Autom√°tica</p>
                </div>
            </div>
            
            <!-- Bot√£o para o mapa -->
            <div class="flex gap-2 mt-4">
                <button onclick="abrirMapa()" class="bg-gradient-to-r from-blue-500 to-cyan-500 hover:from-blue-600 hover:to-cyan-600 text-white px-4 py-2 rounded-lg font-medium transition-all flex items-center gap-2">
                    üó∫Ô∏è Ver Mapa de Origens
                </button>
            </div>
            
            <!-- Upload Area -->
            <div class="bg-gradient-to-r from-blue-50 to-purple-50 rounded-2xl p-6 border-2 border-dashed border-purple-300 text-center">
                <div class="text-6xl mb-4">üì∏</div>
                <h3 class="text-xl font-bold text-gray-800 mb-2">Envie o Screenshot da Corrida da 99</h3>
                <p class="text-gray-600 mb-4">O app vai ler automaticamente e salvar apenas se for acima de R$ 35</p>
                
                <label class="bg-gradient-to-r from-purple-500 to-pink-500 text-white px-8 py-4 rounded-xl font-bold cursor-pointer hover:from-purple-600 hover:to-pink-600 transition-all inline-flex items-center gap-2">
                    <span>üì§</span>
                    <span id="upload-text">Selecionar Screenshot</span>
                    <input type="file" id="screenshot-input" accept="image/*" class="hidden">
                </label>
                
                <div id="loading" class="mt-4 hidden">
                    <div class="bg-yellow-100 text-yellow-800 px-4 py-2 rounded-lg inline-flex items-center gap-2">
                        <div class="loading rounded-full h-4 w-4 border-2 border-yellow-600 border-t-transparent"></div>
                        <span id="ocr-progress-text">Analisando imagem com OCR...</span>
                    </div>
                </div>

                <!-- Debug OCR Text -->
                <div id="debug-ocr" class="mt-4 hidden">
                    <details class="bg-gray-100 p-3 rounded-lg text-left">
                        <summary class="cursor-pointer text-sm font-medium text-gray-700">Ver texto extra√≠do pelo OCR</summary>
                        <pre id="ocr-text" class="mt-2 text-xs text-gray-600 whitespace-pre-wrap max-h-40 overflow-y-auto"></pre>
                    </details>
                </div>
            </div>

            <!-- Status -->
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mt-6">
                <div class="bg-green-50 p-4 rounded-xl text-center">
                    <div class="text-2xl font-bold text-green-600" id="total-corridas">0</div>
                    <div class="text-sm text-gray-600">Corridas Capturadas</div>
                </div>
                <div class="bg-blue-50 p-4 rounded-xl text-center">
                    <div class="text-2xl font-bold text-blue-600">R$ 35+</div>
                    <div class="text-sm text-gray-600">Filtro M√≠nimo</div>
                </div>
                <div class="bg-purple-50 p-4 rounded-xl text-center">
                    <div class="text-2xl font-bold text-purple-600" id="total-prints">0</div>
                    <div class="text-sm text-gray-600">Prints Salvos</div>
                </div>
                <div class="bg-orange-50 p-4 rounded-xl text-center">
                    <div class="text-2xl font-bold text-orange-600" id="ultimo-ocr">--:--</div>
                    <div class="text-sm text-gray-600">√öltimo OCR</div>
                </div>
            </div>
        </div>

        <!-- An√°lises -->
        <div id="analises" class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6 hidden">
            <div class="bg-white/95 backdrop-blur-sm rounded-2xl shadow-xl p-6">
                <div class="flex items-center gap-2 mb-4">
                    <span class="text-2xl">üìç</span>
                    <h3 class="text-lg font-bold text-gray-800">üéØ Melhores Locais</h3>
                </div>
                <div id="melhores-locais" class="space-y-3">
                    <!-- Ser√° preenchido via JavaScript -->
                </div>
            </div>

            <div class="bg-white/95 backdrop-blur-sm rounded-2xl shadow-xl p-6">
                <div class="flex items-center gap-2 mb-4">
                    <span class="text-2xl">‚è∞</span>
                    <h3 class="text-lg font-bold text-gray-800">‚è∞ Melhores Hor√°rios</h3>
                </div>
                <div id="melhores-horarios" class="space-y-3">
                    <!-- Ser√° preenchido via JavaScript -->
                </div>
            </div>

            <div class="bg-white/95 backdrop-blur-sm rounded-2xl shadow-xl p-6">
                <div class="flex items-center gap-2 mb-4">
                    <span class="text-2xl">üìä</span>
                    <h3 class="text-lg font-bold text-gray-800">üìÖ Melhores Dias</h3>
                </div>
                <div id="melhores-dias" class="space-y-3">
                    <!-- Ser√° preenchido via JavaScript -->
                </div>
            </div>
        </div>

        <!-- Hist√≥rico -->
        <div class="bg-white/95 backdrop-blur-sm rounded-2xl shadow-xl p-6">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-bold text-gray-800">üì∏ Prints Capturados (<span id="count-historico">0</span>)</h3>
                <button id="limpar-tudo" class="text-sm text-red-500 hover:text-red-700 px-3 py-1 rounded-lg bg-red-50">
                    üóëÔ∏è Limpar tudo
                </button>
            </div>
            
            <div id="historico-vazio" class="text-center py-12">
                <div class="text-6xl mb-4">üì∑</div>
                <p class="text-gray-500 text-lg">Nenhum screenshot processado ainda</p>
                <p class="text-gray-400">Envie uma imagem de corrida da 99 para come√ßar</p>
            </div>

            <div id="historico-list" class="space-y-4 hidden">
                <!-- Ser√° preenchido via JavaScript -->
            </div>
        </div>
    </div>

    <script>
        // Configura√ß√µes de pr√©-processamento
        const SCALE_FACTOR = 2;
        const CONTRAST_PERCENT = 130;
        const BRIGHTNESS_PERCENT = 105;
        const filtroValor = 35;
        const MIN_FONTHEIGHT_PX = 8;

        // Estado da aplica√ß√£o
        let corridasCapturadas = [];
        let printsArmazenados = [];

        // Elementos DOM
        const uploadInput = document.getElementById('screenshot-input');
        const uploadText = document.getElementById('upload-text');
        const loading = document.getElementById('loading');
        const progressText = document.getElementById('ocr-progress-text');
        const totalCorridas = document.getElementById('total-corridas');
        const totalPrints = document.getElementById('total-prints');
        const ultimoOCR = document.getElementById('ultimo-ocr');
        const analises = document.getElementById('analises');
        const historicoVazio = document.getElementById('historico-vazio');
        const historicoList = document.getElementById('historico-list');
        const countHistorico = document.getElementById('count-historico');
        const limparTudoBtn = document.getElementById('limpar-tudo');
        const debugOcr = document.getElementById('debug-ocr');
        const ocrText = document.getElementById('ocr-text');

        // Carregar dados salvos
        function carregarDados() {
            const corridasSalvas = localStorage.getItem('corridasOCR99');
            const printsSalvos = localStorage.getItem('printsOCR99');
            
            if (corridasSalvas) {
                corridasCapturadas = JSON.parse(corridasSalvas);
            }
            if (printsSalvos) {
                printsArmazenados = JSON.parse(printsSalvos);
            }
            
            atualizarInterface();
        }

        // Salvar dados
        function salvarDados() {
            localStorage.setItem('corridasOCR99', JSON.stringify(corridasCapturadas));
            localStorage.setItem('printsOCR99', JSON.stringify(printsArmazenados));
        }

        // Pr√©-processamento de imagem
        function preprocessImage(file, scale = SCALE_FACTOR, contrastPercent = CONTRAST_PERCENT, brightnessPercent = BRIGHTNESS_PERCENT) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const fr = new FileReader();
                fr.onload = () => { img.src = fr.result; };
                fr.onerror = reject;
                img.onload = () => {
                    const w = img.naturalWidth * scale;
                    const h = img.naturalHeight * scale;
                    const canvas = document.createElement('canvas');
                    canvas.width = w;
                    canvas.height = h;
                    const ctx = canvas.getContext('2d');

                    // Limpar fundo e aplicar filtros
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, w, h);
                    ctx.filter = `contrast(${contrastPercent}%) brightness(${brightnessPercent}%)`;
                    ctx.drawImage(img, 0, 0, w, h);

                    resolve({ dataURL: canvas.toDataURL('image/png'), width: w, height: h });
                };
                fr.readAsDataURL(file);
            });
        }

        // Normalizar palavras do OCR
        function normalizeWord(w) {
            const bbox = w.bbox || (w.boundingBox ? w.boundingBox : null);
            let x0, y0, x1, y1;
            if (bbox && typeof bbox.x0 !== 'undefined') {
                x0 = bbox.x0; y0 = bbox.y0; x1 = bbox.x1; y1 = bbox.y1;
            } else {
                x0 = w.x0 || w.x || 0;
                y0 = w.y0 || w.y || 0;
                x1 = w.x1 || (x0 + (w.width || 0));
                y1 = w.y1 || (y0 + (w.height || 0));
            }
            const width = Math.max(1, x1 - x0);
            const height = Math.max(1, y1 - y0);
            return {
                text: (w.text || w.symbol || '').toString().trim(),
                conf: (typeof w.confidence !== 'undefined') ? w.confidence : (w.conf || 0),
                x: x0, y: y0, x1, y1, width, height
            };
        }

        // Agrupar palavras em linhas
        function buildLines(words, imageHeight) {
            const lines = [];
            const tolerance = Math.max(10, imageHeight * 0.02);
            words.sort((a, b) => a.y - b.y || a.x - b.x);

            for (const w of words) {
                const midY = w.y + w.height / 2;
                let placed = false;
                for (const line of lines) {
                    const lineMid = line.y + line.height / 2;
                    if (Math.abs(lineMid - midY) <= tolerance) {
                        line.words.push(w);
                        line.x = Math.min(line.x, w.x);
                        line.y = Math.min(line.y, w.y);
                        line.x1 = Math.max(line.x1, w.x1);
                        line.y1 = Math.max(line.y1, w.y1);
                        line.width = line.x1 - line.x;
                        line.height = line.y1 - line.y;
                        line.avgConf = (line.avgConf * (line.count) + w.conf) / (line.count + 1);
                        line.count += 1;
                        placed = true;
                        break;
                    }
                }
                if (!placed) {
                    lines.push({
                        words: [w],
                        x: w.x, y: w.y, x1: w.x1, y1: w.y1,
                        width: w.width, height: w.height,
                        avgConf: w.conf,
                        count: 1
                    });
                }
            }

            // Montar texto por linha
            for (const l of lines) {
                l.words.sort((a, b) => a.x - b.x);
                l.text = l.words.map(w => w.text).join(' ').replace(/\s{2,}/g, ' ').trim();
                l.centerX = l.x + l.width / 2;
                l.centerY = l.y + l.height / 2;
                l.fontHeight = Math.max(...l.words.map(w => w.height));
            }

            lines.sort((a, b) => a.y - b.y);
            return lines;
        }

        // Extrair valores monet√°rios
        function parseMonetaryFromLines(lines, imageWidth, imageHeight) {
            const moneyRegex = /(R\$)?\s*([0-9]{1,3}(?:[.,][0-9]{3})*(?:[.,][0-9]{2}))|([0-9]+[.,][0-9]{2})/i;
            const candidates = [];

            for (const line of lines) {
                if (!line.text) continue;
                const m = line.text.match(moneyRegex);
                if (m) {
                    let numberRaw = (m[2] || m[3] || '').trim();
                    if (!numberRaw) continue;
                    let cleaned = numberRaw.replace(/\./g, '').replace(',', '.');
                    const numeric = parseFloat(cleaned);
                    if (!isFinite(numeric)) continue;
                    
                    const posScoreX = (line.centerX / imageWidth);
                    const posScoreY = (line.centerY / imageHeight);
                    const fontScore = Math.max(line.fontHeight, MIN_FONTHEIGHT_PX);
                    const confScore = line.avgConf || 0.5;
                    const score = Math.log(numeric + 1) * (fontScore) * (1 + posScoreX) * (1 + posScoreY) * (1 + confScore/100);

                    candidates.push({
                        numeric,
                        cleaned,
                        text: line.text,
                        line,
                        score
                    });
                }
            }

            if (candidates.length === 0) return null;

            // Preferir candidatos acima do filtroValor
            const aboveFilter = candidates.filter(c => c.numeric >= filtroValor);
            if (aboveFilter.length > 0) {
                aboveFilter.sort((a, b) => b.score - a.score);
                return aboveFilter[0];
            }
            
            candidates.sort((a, b) => {
                if (b.numeric !== a.numeric) return b.numeric - a.numeric;
                return b.score - a.score;
            });
            return candidates[0];
        }

        // Extra√ß√£o avan√ßada de dados
        function extrairDadosCorridaAvancado(textoOCR, ocrData, imageWidth, imageHeight) {
            const textoNormalizado = (textoOCR || '').replace(/[\u200B-\u200D\uFEFF]/g, '').replace(/\s{2,}/g, ' ').trim();
            const rawWords = (ocrData && ocrData.words) ? ocrData.words : [];
            const words = rawWords.map(normalizeWord).filter(w => w.text && w.text.trim().length > 0);
            const lines = buildLines(words, imageHeight);
            
            // Detectar valor
            const candidateGlobal = parseMonetaryFromLines(lines, imageWidth, imageHeight);
            const linesRightBottom = lines.filter(l => l.centerX > imageWidth*0.4 && l.centerY > imageHeight*0.2);
            const candidateRB = parseMonetaryFromLines(linesRightBottom, imageWidth, imageHeight);
            
            let chosen = candidateGlobal;
            if (candidateRB) {
                if (!chosen) chosen = candidateRB;
                else {
                    if (candidateRB.numeric > chosen.numeric * 0.99) {
                        chosen = (candidateRB.score >= chosen.score) ? candidateRB : chosen;
                    } else if (chosen.numeric < candidateRB.numeric) {
                        chosen = candidateRB;
                    }
                }
            }

            if (!chosen) {
                const fallbackMatch = textoNormalizado.match(/R\$\s*([0-9.,]+)/i);
                if (fallbackMatch) {
                    const raw = fallbackMatch[1].replace(/\./g, '').replace(',', '.');
                    chosen = { numeric: parseFloat(raw), text: fallbackMatch[0], line: { text: fallbackMatch[0] } };
                }
            }

            const valor = chosen ? chosen.numeric : null;
            
            // Extrair origem/destino
            let origem = "Origem n√£o identificada";
            let destino = "Destino n√£o identificado";
            
            const labelRegexOrigem = /\b(origem)\b[:\s-]*/i;
            const labelRegexDestino = /\b(destino)\b[:\s-]*/i;
            const addressKeywords = /\b(rua|r\.|av|avenida|estrada|rodovia|pra√ßa|terminal|parque|alameda|bairro|embarque|t2|terminal 2)\b/i;

            for (let i = 0; i < lines.length; i++) {
                const t = lines[i].text;
                if (!t) continue;
                
                if (labelRegexOrigem.test(t)) {
                    origem = t.replace(labelRegexOrigem, '').trim();
                    if (!origem && lines[i+1]) origem = lines[i+1].text.trim();
                }
                
                if (labelRegexDestino.test(t)) {
                    destino = t.replace(labelRegexDestino, '').trim();
                    if (!destino && lines[i+1]) destino = lines[i+1].text.trim();
                }
            }

            // Fallback para endere√ßos
            const addressLines = lines.filter(l => addressKeywords.test(l.text));
            if (origem === "Origem n√£o identificada" && addressLines.length >= 1) {
                origem = addressLines[0].text;
            }
            if (destino === "Destino n√£o identificado" && addressLines.length >= 2) {
                destino = addressLines[1].text;
            }

            // Limpar e truncar endere√ßos
            origem = origem.replace(/\s{2,}/g, ' ').replace(/^\W+|\W+$/g, '').trim();
            destino = destino.replace(/\s{2,}/g, ' ').replace(/^\W+|\W+$/g, '').trim();
            
            if (origem.length > 60) origem = origem.substring(0, 57) + '...';
            if (destino.length > 60) destino = destino.substring(0, 57) + '...';

            // Extrair tempo e dist√¢ncia
            let tempoCorrida = null, distanciaCorrida = null, tempoPegar = null, distanciaPegar = null;
            const tempoMatch = textoNormalizado.match(/(\d+)\s*min/i);
            if (tempoMatch) tempoCorrida = tempoMatch[1] + 'min';
            const distanciaMatch = textoNormalizado.match(/([\d.,]+)\s*km/i);
            if (distanciaMatch) distanciaCorrida = distanciaMatch[1].replace(',', '.') + 'km';

            // Extrair avalia√ß√£o
            let avaliacao = null, corridasPassageiro = null;
            const avaliacaoPatterns = [
                /(\d+[.,]\d+)\s*[¬∑‚Ä¢\-]\s*(\d+)\s*corridas?/i,
                /(\d+[.,]\d+)\s*(\d+)\s*corridas?/i,
                /[‚òÖ‚≠ê]\s*(\d+[.,]\d+).*?(\d+)\s*corridas?/i
            ];
            for (const p of avaliacaoPatterns) {
                const m = textoNormalizado.match(p);
                if (m) { 
                    avaliacao = m[1].replace(',', '.'); 
                    corridasPassageiro = m[2] + ' corridas'; 
                    break; 
                }
            }

            const corridaLonga = textoNormalizado.toLowerCase().includes("corrida longa");

            return {
                valor,
                avaliacao,
                corridasPassageiro,
                tempoPegar,
                distanciaPegar,
                tempoCorrida,
                distanciaCorrida,
                origem,
                destino,
                dataHora: new Date().toISOString(),
                diaSemana: new Date().getDay(),
                hora: new Date().getHours(),
                corridaLonga
            };
        }

        // Processar screenshot com OCR
        async function processarScreenshot(arquivo) {
            if (!arquivo) return;

            loading.classList.remove('hidden');
            debugOcr.classList.add('hidden');
            progressText.textContent = "Analisando imagem com OCR...";
            uploadText.textContent = 'Processando...';

            try {
                // Pr√©-processar imagem
                const { dataURL, width, height } = await preprocessImage(arquivo, SCALE_FACTOR, CONTRAST_PERCENT, BRIGHTNESS_PERCENT);

                // Executar OCR
                const { data } = await Tesseract.recognize(
                    dataURL,
                    'por',
                    {
                        logger: progresso => {
                            if (progresso.status === 'recognizing text') {
                                const progressoPorcentagem = Math.round(progresso.progress * 100);
                                progressText.textContent = `OCR: ${progressoPorcentagem}%`;
                            }
                        }
                    }
                );

                console.log("Dados OCR:", data);
                ocrText.textContent = data.text || '';
                debugOcr.classList.remove('hidden');
                
                // Extrair dados avan√ßados
                const dados = extrairDadosCorridaAvancado(data.text, data, width, height);
                
                if (!dados.valor) {
                    alert("‚ùå N√£o foi poss√≠vel identificar o valor da corrida. Verifique se √© uma tela de corrida da 99 v√°lida.");
                    return;
                }

                if (dados.valor < filtroValor) {
                    alert(`‚ùå Corrida de R$ ${dados.valor.toFixed(2)} ignorada (abaixo de R$ ${filtroValor})`);
                    return;
                }

                // Salvar corrida
                const reader = new FileReader();
                reader.onload = (e) => {
                    const novaCorrida = {
                        id: Date.now(),
                        valor: dados.valor,
                        avaliacao: dados.avaliacao,
                        corridasPassageiro: dados.corridasPassageiro,
                        tempoPegar: dados.tempoPegar,
                        distanciaPegar: dados.distanciaPegar,
                        tempoCorrida: dados.tempoCorrida,
                        distanciaCorrida: dados.distanciaCorrida,
                        origem: dados.origem,
                        destino: dados.destino,
                        dataHora: dados.dataHora,
                        diaSemana: dados.diaSemana,
                        hora: dados.hora,
                        screenshot: e.target.result
                    };

                    corridasCapturadas.unshift(novaCorrida);
                    printsArmazenados.unshift({
                        id: novaCorrida.id,
                        imagem: e.target.result,
                        dados: dados,
                        dataHora: novaCorrida.dataHora
                    });

                    salvarDados();
                    atualizarInterface();
                    
                    alert(`‚úÖ Corrida de R$ ${dados.valor.toFixed(2)} capturada com sucesso!\n\nOrigem: ${dados.origem}\nDestino: ${dados.destino}${dados.tempoCorrida ? '\nTempo: ' + dados.tempoCorrida : ''}${dados.distanciaCorrida ? '\nDist√¢ncia: ' + dados.distanciaCorrida : ''}`);
                };
                
                reader.readAsDataURL(arquivo);

            } catch (error) {
                alert('‚ùå Erro ao processar screenshot. Tente novamente com uma imagem mais n√≠tida.');
                console.error("Erro no OCR:", error);
            } finally {
                loading.classList.add('hidden');
                uploadText.textContent = 'Selecionar Screenshot';
                uploadInput.value = '';
            }
        }

        // Atualizar a interface
        function atualizarInterface() {
            totalCorridas.textContent = corridasCapturadas.length;
            totalPrints.textContent = printsArmazenados.length;
            countHistorico.textContent = corridasCapturadas.length;
            ultimoOCR.textContent = corridasCapturadas.length > 0 ? 
                new Date(corridasCapturadas[0].dataHora).toLocaleTimeString('pt-BR') : '--:--';

            if (corridasCapturadas.length === 0) {
                historicoVazio.classList.remove('hidden');
                historicoList.classList.add('hidden');
                analises.classList.add('hidden');
            } else {
                historicoVazio.classList.add('hidden');
                historicoList.classList.remove('hidden');
                analises.classList.remove('hidden');
                renderizarHistorico();
                renderizarAnalises();
            }
        }

        // Renderizar hist√≥rico de corridas
        function renderizarHistorico() {
            historicoList.innerHTML = corridasCapturadas.slice(0, 10).map(corrida => `
                <div class="card-corrida border border-gray-200 rounded-xl p-4 bg-white">
                    <div class="flex justify-between items-start mb-3">
                        <div class="flex items-center gap-2 flex-wrap">
                            <div class="bg-gradient-to-r from-purple-500 to-pink-500 text-white px-3 py-1 rounded-full font-bold text-sm">
                                R$ ${corrida.valor.toFixed(2)}
                            </div>
                            <div class="text-xs text-gray-500">
                                ${new Date(corrida.dataHora).toLocaleString('pt-BR')}
                            </div>
                            ${corrida.avaliacao ? `
                            <div class="info-badge bg-yellow-100 text-yellow-800">
                                ‚≠ê ${corrida.avaliacao} ${corrida.corridasPassageiro ? '('+corrida.corridasPassageiro+')' : ''}
                            </div>
                            ` : ''}
                            ${corrida.tempoCorrida ? `
                            <div class="info-badge bg-blue-100 text-blue-800">
                                ‚è±Ô∏è ${corrida.tempoCorrida}
                            </div>
                            ` : ''}
                            ${corrida.distanciaCorrida ? `
                            <div class="info-badge bg-green-100 text-green-800">
                                üìè ${corrida.distanciaCorrida}
                            </div>
                            ` : ''}
                            ${corrida.corridaLonga ? `
                            <div class="info-badge bg-purple-100 text-purple-800">
                                üöó Corrida Longa
                            </div>
                            ` : ''}
                        </div>
                        <button onclick="excluirCorrida(${corrida.id})" class="text-red-500 hover:text-red-700">
                            üóëÔ∏è
                        </button>
                    </div>
                    <div class="space-y-3">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div class="space-y-2">
                                <div class="flex items-start gap-2 text-sm">
                                    <span class="text-green-600 mt-1">üìç</span>
                                    <div>
                                        <div class="font-medium">Origem:</div>
                                        <div class="text-gray-600">${corrida.origem}</div>
                                    </div>
                                </div>
                                <div class="flex items-start gap-2 text-sm">
                                    <span class="text-red-600 mt-1">üìç</span>
                                    <div>
                                        <div class="font-medium">Destino:</div>
                                        <div class="text-gray-600">${corrida.destino}</div>
                                    </div>
                                </div>
                            </div>
                            ${corrida.screenshot ? `
                            <div class="flex justify-end">
                                <img src="${corrida.screenshot}" alt="Screenshot" 
                                     class="w-24 h-24 object-cover rounded-lg border-2 border-gray-200 cursor-pointer hover:scale-110 transition-transform"
                                     onclick="window.open('${corrida.screenshot}', '_blank')">
                            </div>
                            ` : ''}
                        </div>
                        
                        ${corrida.distanciaPegar ? `
                        <div class="flex items-center gap-2 text-sm bg-indigo-50 p-3 rounded-lg">
                            <span class="text-indigo-600">üöó</span>
                            <span class="font-medium">Dist√¢ncia para pegar PS:</span>
                            <span class="text-gray-600">${corrida.distanciaPegar} ${corrida.tempoPegar ? '('+corrida.tempoPegar+')' : ''}</span>
                        </div>
                        ` : ''}
                    </div>
                </div>
            `).join('');
        }

        // Renderizar an√°lises (estat√≠sticas)
        function renderizarAnalises() {
            const porDestino = {};
            const porOrigem = {};
            const porHora = {};
            const porDia = {};

            corridasCapturadas.forEach(corrida => {
                const destinoKey = corrida.destino || "Sem destino";
                const origemKey = corrida.origem || "Sem origem";
                
                // Estat√≠sticas por destino
                if (!porDestino[destinoKey]) porDestino[destinoKey] = { total: 0, count: 0 };
                porDestino[destinoKey].total += corrida.valor;
                porDestino[destinoKey].count++;
                
                // Estat√≠sticas por origem
                if (!porOrigem[origemKey]) porOrigem[origemKey] = { total: 0, count: 0 };
                porOrigem[origemKey].total += corrida.valor;
                porOrigem[origemKey].count++;

                // Estat√≠sticas por hora
                if (!porHora[corrida.hora]) porHora[corrida.hora] = { total: 0, count: 0 };
                porHora[corrida.hora].total += corrida.valor;
                porHora[corrida.hora].count++;

                // Estat√≠sticas por dia
                const dias = ['Domingo', 'Segunda', 'Ter√ßa', 'Quarta', 'Quinta', 'Sexta', 'S√°bado'];
                const nomeDia = dias[corrida.diaSemana];
                if (!porDia[nomeDia]) porDia[nomeDia] = { total: 0, count: 0 };
                porDia[nomeDia].total += corrida.valor;
                porDia[nomeDia].count++;
            });

            const criarRanking = (dados) => Object.entries(dados)
                .map(([key, value]) => ({
                    nome: key,
                    media: (value.total / value.count).toFixed(2),
                    quantidade: value.count
                }))
                .sort((a, b) => parseFloat(b.media) - parseFloat(a.media))
                .slice(0, 5);

            const renderizarCard = (items, containerId) => {
                const container = document.getElementById(containerId);
                if (items.length === 0) {
                    container.innerHTML = '<div class="text-center py-4 text-gray-500">Sem dados suficientes</div>';
                    return;
                }
                
                container.innerHTML = items.map(item => `
                    <div class="flex items-center justify-between p-3 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg border-l-4 border-indigo-500 mb-2">
                        <div class="w-3/4">
                            <div class="font-semibold text-gray-800 text-sm truncate">${item.nome}</div>
                            <div class="text-xs text-gray-600">${item.quantidade} corridas</div>
                        </div>
                        <div class="text-right w-1/4">
                            <div class="font-bold text-indigo-700">R$ ${item.media}</div>
                            <div class="text-xs text-gray-500">m√©dia</div>
                        </div>
                    </div>
                `).join('');
            };

            renderizarCard(criarRanking(porDestino), 'melhores-locais');
            renderizarCard(criarRanking(porHora).map(h => ({...h, nome: h.nome + ':00h'})), 'melhores-horarios');
            renderizarCard(criarRanking(porDia), 'melhores-dias');
        }

        // Excluir uma corrida
        function excluirCorrida(id) {
            if (confirm('Deseja excluir esta corrida?')) {
                corridasCapturadas = corridasCapturadas.filter(c => c.id !== id);
                printsArmazenados = printsArmazenados.filter(p => p.id !== id);
                salvarDados();
                atualizarInterface();
            }
        }

        // Limpar todos os dados
        function limparTudo() {
            if (confirm('Deseja realmente excluir TODOS os dados?')) {
                corridasCapturadas = [];
                printsArmazenados = [];
                salvarDados();
                atualizarInterface();
            }
        }

        // Fun√ß√£o para abrir o mapa
        function abrirMapa() {
            window.open('mapa.html', '_blank');
        }

        // Event listeners
        uploadInput.addEventListener('change', (e) => {
            const arquivo = e.target.files[0];
            if (arquivo) {
                processarScreenshot(arquivo);
            }
        });
        
        limparTudoBtn.addEventListener('click', limparTudo);

        // Inicializar
        document.addEventListener('DOMContentLoaded', () => {
            carregarDados();
            
            // PWA Installation
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js')
                    .then(() => console.log('Service Worker registrado'))
                    .catch(() => console.log('Service Worker falhou'));
            }
        });
    </script>
</body>
</html>
